The flow of the functionality.

## Registation
* Each signer generates a key pair to be used for EdDSA.
  * The secret key is an element of the scalar field $\mathbb{F}_r$ of the Jubjub elliptic curve.
  * The public key is an affine point on Jubjub curve. It is of the form `(u, v)`. The coordinates are elements of the scalar field $\mathbb{F}_q$ of the BLS12-381 elliptic curve construction.
* Signers share their public keys with the registration authority.
* Registration authority collects the `u` coordinates of all the public keys in a list.
* The aggregated public key is generated by hashing the list that includes `u` coordinates of all the public keys.
  * The hash output is an element of the base field $\mathbb{F}_q$ of the Jubjub elliptic curve construction.

## Signing
Each signer generates a Schnorr signature and does the following:
* Announcement:
  * Generate a random scalar on the scalar field $\mathbb{F}_r$ of the Jubjub elliptic curve. 
  * Multiply the random scalar with the generator. 
    * The generator is an `ExtendedPoint` of the form `(U, V, Z, T1, T2)`. 
    * So, we convert the multiplication result to an `AffinePoint` of the form `(u, v)`.
* Challenge:
  * Create a list including
    * `x` coordinate of the announcement,
    * `x` coordinate of the public key,
    * The message.
  * Note that, `x` coordinate mentioned above is equivalent to the `u` coordinate. Therefore, all the components of the list are elements of the scalar field $\mathbb{F}_q$ of the BLS12-381 elliptic curve construction.
  * Generate the hash of the list.
    * The hash output is an element of the base field $\mathbb{F}_q$ of the Jubjub elliptic curve construction.
* Response:
  * The response is the addition of the random scalar we used to generate the announcement, the secret key, and the challenge.
  * Note that the random scalar and the secret key are the elements of $\mathbb{F}_r$, but the challenge is an element of the base field $\mathbb{F}_q$. We need to reduce the challenge, so that we can do the addition.
    * Reduce the challenge to $\mathbb{F}_r$.
    * Do the addition.
* Output:
  * Return the announcement which is an `AffinePoint` of the form `(u, v)` and the response which is a scalar, an element in $\mathbb{F}_r$.

## Aggregation
* The aggregator receives signatures sent by the signers and collects the threshold-many of them in a list as the aggregate signature.

## Verification
* The verifier receives:
  * signatures: Schnorr signatures including an `AffinePoint` of the form `(u, v)` and the response which is a scalar, an element in $\mathbb{F}_r$.
  * pks: The list of all public keys. The public keya are affine points of the form `(u, v)` on Jubjub curve. 
  * commited_pks: The aggregated public key, an element of the base field $\mathbb{F}_q$ of the Jubjub elliptic curve construction.
  * msg: The message is an element of the base field $\mathbb{F}_q$ of the Jubjub elliptic curve construction.
  * threshold: The threshold is in the form of an element of the base field $\mathbb{F}_q$ of the Jubjub elliptic curve construction.
* Collects the `x` coordinates of the all public keys in a list and generates a hash of the list.
  * The hash output is an element of the base field $\mathbb{F}_q$ of the Jubjub elliptic curve construction.
* Checks whether the hash output is equal to the committed_pks.
* Iterates though the signatures and the public keys and verifies each signature with respect to the message and the corresponding public key.
* Counts the number of valid signatures.
* Verifier accepts if 
  * The list of public keys produce the committed_pks and
  * There are threshold-many valid signatures.